$[ language java 
   D summary, main "Functions that generate markdown documentation about GET endpoints." ]

$[ function getByIdMarkdown
   D "Generates markdown documentation for the get by ID endpoint."
   (entity
    D "The entity corresponding to the get endpoint documentation to generate.",
    apiUrlPrefix
    D "The start of all admin URLs."
   )
]
## Get ${entity|title} by ID

|Method|Path|
|:---:|:---|
|GET|`${apiUrlPrefix}/${entity|domain:APIPath|name}/{id}`|

Where:

|Param|Description|
|:---|:---|
|`id`|The unique ID of the `${entity.name}` object to be returned.|

    $[ let createViewOrEntity = entity|domain:JSONDTO 
       if entity|domain:JSONDTO|has view:APIGet 
           let createViewOrEntity = entity|domain:JSONDTO|view:APIGet 
       endif 
       let attributeList = createViewOrEntity.attributes|sort 
       let relationshipList = createViewOrEntity.relationships|sort 
       if attributeList#count > 0 ]
The body of the response is JSON containing the following fields:

|Field|Description|
|:---|:---|
        $[ if entity.hasPrimaryKey ]
|`${entity.primaryKeyAttribute.name}`|_Primary Key_|
        $[ endif 
           foreach attribute in attributeList ]
|`${attribute.name}`|${attribute.description}|
        $[ endforeach 
           if relationshipList#count > 0 
               foreach relationship in relationshipList 
                   if relationship.to.entity == null 
                       log error ]In domain: ${relationship.domain.name}: Relationship ${relationship.relationship|fullname} (${relationship.relationship.to.entityName}) does not have a to entity!$[ endlog 
                   endif 
                   if relationship.to.isOne 
                       if relationship.to.entity.entity.hasPrimaryKey && relationship.withViewName == "Reference" ]
|`${relationship.name}.${relationship.to.view.primaryKeyAttribute.name}`|Primary key of contextual `${relationship.to.entity.entity.name}` object.|
                    $[ else ]
|`${relationship.relationship.name}`|`${relationship.to.entity.entity.name}` object.|
                    $[ endif 
                   else 
                       if relationship.to.entity.entity.hasPrimaryKey && relationship.withViewName == "Reference" ]
|`${relationship.name}.${relationship.to.entity.primaryKeyAttribute.name}`|Primary key of contextual `${relationship.to.entity.entity.name}` object.|
                    $[ else ]
|`${relationship.name}[]`|Array of `${relationship.to.entity.entity.name}` objects.|
                    $[ endif 
                   endif 
               endforeach 
           endif 
       endif 
   endfunction ]

$[ function getListByParentMarkdown
           D "Generates markdown documentation for the get list by parent endpoint."(entity
           D "The entity corresponding to the get endpoint documentation to generate.",apiUrlPrefix
           D "The start of all admin URLs.") 
       capture fullTitle ]Get ${entity|title} List$[ endcapture 
       if entity.hasPrimaryParentRelationship 
           let parentEntity = entity.primaryParentRelationship.to.entity
        
           capture fullTitle ]${fullTitle} by *optional* ${parentEntity|name|title} ID$[ endcapture 
       endif ]
## ${fullTitle}

|Method|Path|
|:---:|:---|
|GET|`${apiUrlPrefix}/${entity|domain:APIPath|name}?start={start}&limit={limit}`|

Where:

|Param|Description|
|:---|:---|
    $[ if entity.hasPrimaryParentRelationship 
           let parentEntity = entity.primaryParentRelationship.to.entity 
           capture parentId ]${entity.primaryParentRelationship|domain:Model|name}Id$[ endcapture ]
|`${parentId}`|The unique ID of the parent `${parentEntity.name}` object.|
    $[ endif ]
|`start`|The starting index in the full result set.|
|`limit`|The number of results to return.|

The response JSON is simply an array of the same ${entity.name} objects as returned by the Get ${entity|title} by ID endpoint.
$[ endfunction ]