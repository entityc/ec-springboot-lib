$[ language java ]
$[ domain Model 
   D summary "This template builds what are called Model classes." 
   D "This template builds what are called Model classes. A Model class is used to represent" 
   D "objects of an entity that are used internally on the server. They typically match pretty" 
   D "closely to how they are modeled in the database." 
   D "" 
   D "In addition to creating model class files for the entities it also creates source files for" 
   D "the enums." 
   D "" 
   D "The template also generates markdown documentation about the model classes in a README.md" 
   D "file written at the same level as the model class files. This basically creates" 
   D "documentation when viewed with GitHub." ]

$[ function buildOverrides
   D "In a Springboot Model class, annotations are used to map attribute variables to database"
   D "columns. These can be a bit complicated when secondary entities are involved as the"
   D "hierarchy in the model class can be different than at the database level. This function helps"
   D "in the synthesis of these model variable to column name mappings. This includes both"
   D "attributes and relationships."
   (modelNamePrefix,
    databaseNamePrefix,
    attribute
   )->
   (overrides
   )

       if databaseNamePrefix != null 
           let databaseNamePrefix = databaseNamePrefix + "_" 
           let databaseNamePrefix = databaseNamePrefix + (attribute|domain:Database|name) 
       else 
           let databaseNamePrefix = attribute|domain:Database|name 
       endif 
       let overrides = @[]@ 
       foreach secondaryAttribute in (attribute.getTypeEntity()).attributes 
           if secondaryAttribute.isSecondaryEntityType() 
               let secondaryAttributeName = secondaryAttribute|domain:Model|name 
               if modelNamePrefix != null 
                   let secondaryModelNamePrefix = modelNamePrefix + "." + secondaryAttributeName 
               else 
                   let secondaryModelNamePrefix = secondaryAttributeName 
               endif 
               call buildOverrides(modelNamePrefix: secondaryModelNamePrefix, attribute: secondaryAttribute, databaseNamePrefix: databaseNamePrefix)->(overrides: secondaryOverrides) 
               do overrides.addAll(secondaryOverrides) 
           else 
               let secondaryAttributeName = secondaryAttribute|domain:Model|name 
               if modelNamePrefix == null 
                   capture attributeName ]${secondaryAttributeName}$[ endcapture 
               else 
                   capture attributeName ]${modelNamePrefix}.${secondaryAttributeName}$[ endcapture 
               endif 
               capture columnName ]${databaseNamePrefix}_${secondaryAttribute|domain:Database|name}$[ endcapture 
               let attributeColumnPair = @[attributeName,columnName]@ 
               do overrides.add(attributeColumnPair) 
           endif 
       endforeach 
       foreach secondaryRelationship in (attribute.getTypeEntity()).relationships 
           if secondaryRelationship.to.isOne 
               let secondaryRelationshipName = (secondaryRelationship|domain:Model|name) + "Id" 
               if modelNamePrefix == null 
                   capture attributeName ]${secondaryRelationshipName}$[ endcapture 
               else 
                   capture attributeName ]${modelNamePrefix}.${secondaryRelationshipName}$[ endcapture 
               endif 
               capture columnName ]${databaseNamePrefix}_${secondaryRelationship|domain:Database|name}_id$[ endcapture 
               let attributeColumnPair = @[attributeName,columnName]@ 
               do overrides.add(attributeColumnPair) 
           endif 
       endforeach 
   endfunction ]

$[ import "doc/SourceHeaders" 
   import "release/ReleaseFunctions" 
   file domain.namespace|path "README" "md" ]
# Model Classes

Model classes closely represent how data is stored in the database and even include Spring Framework annotations to tie it to the database. The Repository classes are made to return objects of these classes.

# Entities

The following is the list of entities generated here by module:

    $[ foreach space.modules|sort 
           if module.isIncluded ]$[ continue ]$[ endif ]
## ${module.name|title}

### Entities

|Name|Description|
|---|---|
        $[ foreach module.entities|sort 
               if entity.isImplicit || entity.isExtern ]$[ continue ]$[ endif 
               if entity.hasTag("template") && entity.hasTag("release") 
                   let parentEntity = entity.primaryParentRelationship.to.entity ]
|${entity|domain|name}|_Generated by entity template `${entity.templateName}` in order to associate objects of `${entity.entityOfTemplateArg("C")|name}` to `${parentEntity.name}` objects as part of release management._|
            $[ else ]
|${entity.name}|${entity.description}|
            $[ endif 
           endforeach ]

        $[ if module.hasEnums() ]
### Enums

|Name|Description|
|---|---|
            $[ foreach module.enums|sort 
                   if enum.itemCount > 0 ]
|${enum.name}|${enum.description}
                $[ endif 
               endforeach ]

        $[ endif 
       endforeach ]

## Generated by

Template: `${__template.name}`

$[ endfile 
   foreach module in space.modules if !module.isIncluded 
       foreach entity in module.entities if !(entity.isImplicit || entity.isExtern || entity.isTransient) 
           file domain.namespace|path entity|domain|name "java" 
               publisher springboot.model 
                   call entityHeader(title: "This is the Model class for following entity.") 
                   call CheckIfReleasedEntity(entity: entity)->(isReleasedEntity: isReleasedEntity) ]
package ${domain.namespace};

import java.util.Date;
import java.util.UUID;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

import org.hibernate.annotations.Type;
$[ receive distinct imports ]
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
                $[ foreach attribute in entity.attributes if !attribute.isVirtual && attribute.type.isEnumType ]
import ${attribute.type|domain:Model|fullname};
                $[ endforeach ]

                $[ if entity.isSecondary 
   send imports ]
import javax.persistence.Embeddable;
$[ endsend ]
@Embeddable
@Data
@NoArgsConstructor
@AllArgsConstructor
                $[ else ]
@Entity
@Data
                    $[ if isReleasedEntity ]
@Immutable
$[ send imports ]
import org.hibernate.annotations.Immutable;
$[ endsend 
                       endif ]
@NoArgsConstructor
@AllArgsConstructor
$[ outlet classAnnotations
                   D "Annotations on the entity model class." 
   endoutlet ]
@Table(name = "${entity|domain:Database|name}")
                $[ endif ]
public class ${entity|domain|name}
{
                $[ if entity.hasPrimaryKey ]
    @Id
                    $[ if entity.pkType.isUUIDType ]
    @Type(type="pg-uuid")
                    $[ endif ]
    @Column(name = "${entity.primaryKeyAttribute|domain:Database|name}")
    private ${entity.pkType|language nullable} ${entity.primaryKeyAttribute|domain|name};

                $[ endif 
                   /*  ATTRIBUTES */
                
                   foreach attribute in entity.attributes if !attribute.isVirtual    /* filter out virtuals */ 
                       let databaseAttributeName = attribute|domain:Database|name 
                       if attribute.hasDescription ]
    // ${attribute.description}
                    $[ endif 
                       let sinceVersion = (attribute|domain:Database).sinceSchemaVersion 
                       if sinceVersion > 0 ]
    // (since database schema v${sinceVersion})
                    $[ endif 
                       if attribute.isArray 
                           /* ARRAY */ 
   send imports ]
import javax.persistence.CollectionTable;
import javax.persistence.ElementCollection;
import javax.persistence.JoinColumn;
import javax.persistence.FetchType;
import org.hibernate.annotations.Fetch;
import org.hibernate.annotations.FetchMode;
$[ endsend ]
    @ElementCollection(fetch=FetchType.EAGER)
    @Fetch(FetchMode.SUBSELECT)
    @CollectionTable(
            name = "${entity|domain:Database|name}_${attribute|domain:Database|name}",
            joinColumns = @JoinColumn(name = "${entity.primaryKeyAttribute|domain:Database|name}")
    )
                        $[ if !entity.isSecondary ]
    @Column(name = "value")
                        $[ endif 
   send imports ]
import java.util.HashSet;
import java.util.Set;
$[ endsend ]
    private Set<${attribute.type|language nullable}> ${attribute|domain|name} = new HashSet<>();
                    $[ else 
                           /* NOT ARRAY */ 
                           if !entity.isSecondary 
                               if attribute.isSecondaryEntityType() 
   send imports ]
import javax.persistence.AttributeOverrides;
import javax.persistence.AttributeOverride;
$[ endsend ]
    @AttributeOverrides({
                                $[ call buildOverrides(modelNamePrefix: null, attribute: attribute, databaseNamePrefix: null)->(overrides: overrides) 
                                   foreach override in overrides.values ]
            @AttributeOverride(name="${override.get(0)}", column=@Column(name="${override.get(1)}"))$[ if !override#last ],$[ endif ]

                                $[ endforeach ]
    })
$[ send imports ]
import javax.persistence.Embedded;
$[ endsend ]
    @Embedded
                            $[ elseif attribute.isCreation ]
    @Column(name = "${databaseAttributeName}", insertable = false, updatable = false)
                            $[ elseif attribute.isModification ]
    @Column(name = "${databaseAttributeName}", insertable = false, updatable = false)
                            $[ elseif attribute.isSequential ]
    @Column(name = "${databaseAttributeName}", insertable = false, updatable = false)
                            $[ else ]
    @Column(name = "${databaseAttributeName}")
                            $[ endif    /* end secondary entity type */ 
                           endif    /* end !entity is secondary */ 
                           if sinceVersion > 1 
                               let coalesceValue = 0 
                               switch attribute.type 
                                   case boolean 
                                       let coalesceValue = "false" 
                                   case uuid 
                                       let coalesceValue = "" 
                                   default 
                               endswitch 
   send imports ]
import org.hibernate.annotations.ColumnTransformer;
$[ endsend ]
    @ColumnTransformer(forColumn = "${databaseAttributeName}",
            read = "Coalesce(${databaseAttributeName}, ${coalesceValue})",
            write = "?")
                        $[ endif    /* end sinceVersion > 1 */ 
                           if attribute.type.isByteArrayType ]
    private byte[] ${attribute|domain|name};
                        $[ elseif attribute.type.isEnumType    /* ENUM */ 
                               let enumClassName = attribute.type|language 
                               let defaultAssignment = "" 
                               if attribute.hasDefaultValue 
                                   capture defaultAssignment ] = ${attribute.defaultValue|domain}.getNumberValue()$[ endcapture 
                               endif ]
    private int ${attribute|domain|name}${defaultAssignment};

    public ${enumClassName} get${attribute|domain|name|capitalize}() {
        return ${enumClassName}.numberValueOf(this.${attribute|domain|name});
    }

    public void set${attribute|domain|name|capitalize}(${enumClassName} ${attribute|domain|name}) {
        this.${attribute|domain|name} = ${attribute|domain|name}.getNumberValue();
    }
                        $[ else 
                               let defaultAssignment = "" 
                               if attribute.hasDefaultValue 
                                   capture defaultAssignment ] = ${attribute.defaultValue}$[ endcapture 
                               endif ]
    private ${attribute.type|language nullable} ${attribute|domain|name}${defaultAssignment};
                        $[ endif 
                       endif ]

                    $[ if attribute.isSecondaryEntityType() 
                           let secondaryDEntity = attribute.typeEntity|domain:Model 
                           if attribute.isArray ]
    public Set<${secondaryDEntity.name}> get${attribute|domain|name|capitalize}() {
        return ${attribute|domain|name};
    }
                        $[ else ]
    public ${secondaryDEntity.name} get${attribute|domain|name|capitalize}() {
        if (${attribute|domain|name} == null) {
            ${attribute|domain|name} = new ${secondaryDEntity.name}();
        }
        return ${attribute|domain|name};
    }
                        $[ endif ]

                    $[ endif 
                       if attribute.type.isBooleanType ]
    public boolean is${attribute|domain|name|capitalize}() {
        return ${attribute|domain|name} != null && ${attribute|domain|name};
    }

                    $[ endif 
                   endforeach 
                   /*  RELATIONSHIPS */ 
                   foreach d_relationship in (entity|domain|view:Default).relationships if d_relationship.to.isAsPrimaryKey 
                       let relationship = d_relationship.relationship 
                       if !entity.isSecondary ]
    @Column(name = "${relationship|domain:Database|name}_id") // relationship
                    $[ endif 
                       if relationship.to.entity.primaryKeyAttribute == null 
                           log fatal ]Relationship ${entity.name}.${relationship.name} TO entity ${relationship.to.entity.name} is missing a primary key attribute!$[ endlog 
                       endif ]
    ${relationship.to.entity.primaryKey.type|language nullable} ${d_relationship|name}Id;

                $[ endforeach ]
}
            $[ endpublisher 
           endfile 
       endforeach 
   endforeach 
   /***********/ 
   /*  ENUMS  */ 
   /***********/ 
   foreach space.modules 
       foreach module.enums 
           if enum.isExtern ]$[ continue ]$[ endif 
           file domain.namespace|path enum|domain|name "java" 
               let needsProtobufMapping = space.hasDomain("ProtobufDTO") 
               call enumHeader(title: "This class is for the implementation of the following enum.") ]
package ${domain.namespace};

import com.fasterxml.jackson.annotation.JsonCreator;

public enum ${enum|domain|name} {
            $[ foreach item in enum.items 
                   if item.hasDescription ]
    // ${item.description}
                $[ endif 
                   let extraConstructorArg = needsProtobufMapping ? ", \"" + (enum|domain|name) + "_" + (item|domain|name) + "\"":"" 
                   let title = item|title 
                   if item.hasTag("title") 
                       let title = item.tagValue("title") 
                   endif ]
    ${item|domain|name}(${item.value}, "${title}"${extraConstructorArg}),
            $[ endforeach ]
    ;

            $[ let extraArg = needsProtobufMapping ? ", String protobufValue":"" ]
    ${enum|domain|name}(int numberValue, String title${extraArg}) {
        this.numberValue = numberValue;
        this.title = title;
            $[ if needsProtobufMapping ]
        this.protobufValue = protobufValue;
            $[ endif ]
    }

    private String title;
    public String getTitle() {
        return title;
    }
    private int numberValue;

    public int getNumberValue() {
        return numberValue;
    }

    static public ${enum|domain|name} numberValueOf(int numberValue) {
        for (${enum|domain|name} item : values()) {
            if (item.numberValue == numberValue) {
                return item;
            }
        }
        return null;
    }

            $[ if needsProtobufMapping ]
    private String protobufValue;

    static public ${enum|domain|name} protobufValueOf(String name) {
        for (${enum|domain|name} item : values()) {
            if (item.protobufValue.equals(name)) {
                return item;
            }
        }
        return null;
    }

    public String getProtobufValue() {
        return protobufValue;
    }
                $[*
    /**
     This method is needed to convert by the numberValue field instead of by ordinate.
     */
    @JsonCreator
    public static ${enum|domain|name} fromValue(int value) {
        for (${enum|domain|name} item : ${enum|domain|name}.values()) {
            if (item.numberValue == value) {
                return item;
            }
        }
        throw new IllegalArgumentException("Invalid value for ${enum|domain|name} enum: " + value);
    } *]
              $[ endif ]
}

        $[ endfile 
       endforeach 
   endforeach ]