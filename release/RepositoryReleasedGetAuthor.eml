$[ D summary, main "This template contains the authors that are responsible for generating the get object" ]
$[ D summary, main "repository methods for composite entities in the Released realm." ]
$[ publisher org.entityc.springboot.repository.get ]
    $[ author to org.entityc.springboot.repository ]
        $[ author to outlet methods
           D "Adds many get methods from get by ID to getting lists by parent relationships."
        ]
$[* Only process composite entities here. *]
            $[ call CheckIfReleasedEntity(entity: entity)->(isReleasedEntity: isReleasedEntity, releaseEntityPKAttribute: releaseEntityPKAttribute) ]
            $[ if !isReleasedEntity ]
                $[ return ]
            $[/ if ]
            $[ let binderEntity = entity.getConstituentEntity("binder") ]
            $[ let objectEntity = entity.getConstituentEntity("object") ]
            $[ let versionEntity = entity.getConstituentEntity("version") ]
            $[ let releaseEntity = entity.getConstituentEntity("release") ]
            $[ let objectPKColumnName = objectEntity.primaryKeyAttribute|domain:Database|name ]
            $[ let versionPKColumnName = versionEntity.primaryKeyAttribute|domain:Database|name ]
            $[ let releasePKColumnName = releaseEntity.primaryKeyAttribute|domain:Database|name ]

            $[ let hasCreationDate = false ]
            $[ foreach attribute in entity.effectiveAttributes|type single ]
                $[ if attribute.isCreation ]
                    $[ let hasCreationDate = true ]
                    $[ let creationDateAttribute = attribute ]
                    $[ break ]
                $[/ if ]
            $[/ foreach ]
            $[ let sortByAttribute = null ]
            $[ let ascending = true ]
            $[ foreach attribute in entity.effectiveAttributes|type single ]
                $[ if (attribute|domain).hasTag("sort:asc") ]
                    $[ let sortByAttribute = attribute ]
                    $[ let ascending = true ]
                $[ elseif (attribute|domain).hasTag("sort:desc") ]
                    $[ let sortByAttribute = attribute ]
                    $[ let ascending = false ]
                $[/ if ]
                $[ if sortByAttribute != null ]
                    $[ let sortTableAlias = versionEntity.hasAttributeNamed(sortByAttribute.name) ? "v":"o" ]
                $[/ if ]
            $[/ foreach ]
            $[ if sortByAttribute == null && hasCreationDate ]
                $[ let sortByAttribute = creationDateAttribute ]
                $[ let ascending = false ]
            $[/ if ]
            $[ let responseEntity = entity ]
            $[ let responseModelName = responseEntity|domain:Model|name ]
            $[ let responseDatabaseName = responseEntity|domain:Database|name ]
            $[ if responseEntity.hasPrimaryKey ]
    @Query(value =
        "SELECT * " +
          "FROM ${binderEntity|domain:Database|name} r " +
          "JOIN ${objectEntity|domain:Database|name} o ON r.${objectPKColumnName} = o.${objectPKColumnName} " +
          "JOIN ${versionEntity|domain:Database|name} v ON r.${versionPKColumnName} = v.${versionPKColumnName} " +
         "WHERE r.${releasePKColumnName} = ?1 AND o.${objectPKColumnName} = ?2", nativeQuery = true)
    Optional<${responseModelName}> getById(${releaseEntityPKAttribute.type|language} ${releaseEntityPKAttribute.name}, ${responseEntity.pkType|language} id);
            $[/ if ]
$[ send imports ]
import ${responseEntity|domain:Model|fullname};
$[/ send ]
    /**
     * Gets the full list of ${responseModelName} objects with paging.
     * @param start The starting index.
     * @param limit The maximum number or results to return.
     * @return List of ${responseModelName} objects fetched.
     */
    @Query(value =
        "SELECT * " +
          "FROM ${binderEntity|domain:Database|name} r " +
          "JOIN ${objectEntity|domain:Database|name} o ON r.${objectPKColumnName} = o.${objectPKColumnName} " +
          "JOIN ${versionEntity|domain:Database|name} v ON r.${versionPKColumnName} = v.${versionPKColumnName} " +
         "WHERE r.${releasePKColumnName} = ?1 " +
            $[ if sortByAttribute != null ]
      "ORDER BY ${sortTableAlias}.${sortByAttribute|domain:Database|name} ${ascending ? "ASC":"DESC"} " +
            $[/ if ]
      "LIMIT ?2 OFFSET ?1", nativeQuery = true)
    List<${responseModelName}> get${responseModelName}List(${releaseEntityPKAttribute.type|language} ${releaseEntityPKAttribute.name}, long start, int limit);

    /**
     * Gets the count of ${entity.name} objects for a release.
     * @return Count of ${entity.name} objects for a release.
     */
    @Query(value =
        "SELECT COUNT(*) " +
          "FROM ${binderEntity|domain:Database|name} r " +
          "JOIN ${objectEntity|domain:Database|name} o ON r.${objectPKColumnName} = o.${objectPKColumnName} " +
          "JOIN ${versionEntity|domain:Database|name} v ON r.${versionPKColumnName} = v.${versionPKColumnName} " +
         "WHERE r.${releasePKColumnName} = ?1 ", nativeQuery = true)
    Long count(${releaseEntityPKAttribute.type|language} ${releaseEntityPKAttribute.name});

$[ outlet methods
   D "A good place to add additional repository get methods."
]
$[/ outlet ]
            $[ foreach entity.attributes ]
                $[ if attribute.isParent ]
                    $[ let tableAlias = versionEntity.hasAttributeNamed(attribute.name) ? "v":"o" ]
    /**
     * Gets the list of ${responseModelName} objects that all share the same value for attribute ${attribute.name}.
     * @param ${attribute|domain|name} The value for ${attribute.name}.
     * @param start The starting index.
     * @param limit The maximum number or results to return.
     * @return List of ${responseModelName} objects fetched.
     */
    @Query(value =
        "SELECT * " +
          "FROM ${binderEntity|domain:Database|name} r " +
          "JOIN ${objectEntity|domain:Database|name} o ON r.${objectPKColumnName} = o.${objectPKColumnName} " +
          "JOIN ${versionEntity|domain:Database|name} v ON r.${versionPKColumnName} = v.${versionPKColumnName} " +
         "WHERE r.${releasePKColumnName} = ?1 " +
           "AND ${tableAlias}.${attribute|domain:Database|name} = ?2 " +
                    $[ if sortByAttribute != null ]
      "ORDER BY ${sortTableAlias}.${sortByAttribute|domain:Database|name} ${ascending ? "ASC":"DESC"} " +
                    $[/ if ]
      "LIMIT ?4 OFFSET ?3", nativeQuery = true)
    List<${responseModelName}> get${responseModelName}ListBy${attribute.name|capitalize}(${releaseEntityPKAttribute.type|language} ${releaseEntityPKAttribute.name}, $[ if attribute.type.isEnumType() ]int$[ else ]${attribute.type|language}$[/ if ] ${attribute|domain|name}, long start, int limit);

                $[/ if ]
            $[/ foreach ]
            $[ foreach entity.relationships ]
                $[ if relationship.to.isOne ]
                    $[ let tableAlias = versionEntity.hasRelationshipNamed(relationship.name) ? "v":"o" ]
    /**
     * Gets the list of ${responseModelName} objects that all share the same reference to an object of ${relationship.to.entity.name}.
     * @param ${relationship|domain|name}Id The ID of the ${relationship.to.entity.name} object to which all results will share.
     * @param start The starting index.
     * @param limit The maximum number or results to return.
     * @return List of ${responseModelName} objects fetched.
     */
    @Query(value =
            "SELECT * " +
          "FROM ${binderEntity|domain:Database|name} r " +
          "JOIN ${objectEntity|domain:Database|name} o ON r.${objectPKColumnName} = o.${objectPKColumnName} " +
          "JOIN ${versionEntity|domain:Database|name} v ON r.${versionPKColumnName} = v.${versionPKColumnName} " +
         "WHERE r.${releasePKColumnName} = ?1 " +
           "AND ${tableAlias}.${relationship|domain:Database|name}_id = ?2 " +
                    $[ if sortByAttribute != null ]
            "ORDER BY ${sortTableAlias}.${sortByAttribute|domain:Database|name} ${ascending ? "ASC":"DESC"} " +
                    $[/ if ]
            "LIMIT ?4 OFFSET ?3", nativeQuery = true)
    List<${responseModelName}> get${responseModelName}ListBy${relationship.name|capitalize}(${releaseEntityPKAttribute.type|language} ${releaseEntityPKAttribute.name}, ${relationship.to.entity.primaryKey.type|language} ${relationship|domain|name}Id, long start, int limit);

    /**
     * Gets the count of ${responseModelName} objects that all share the same reference to an object of ${relationship.to.entity.name}.
     * @param ${relationship|domain|name}Id The ID of the ${relationship.to.entity.name} object to which all results will share.
     * @return Count of ${responseModelName} objects that exist.
     */
    @Query(value =
        "SELECT count(*) " +
          "FROM ${binderEntity|domain:Database|name} r " +
          "JOIN ${objectEntity|domain:Database|name} o ON r.${objectPKColumnName} = o.${objectPKColumnName} " +
          "JOIN ${versionEntity|domain:Database|name} v ON r.${versionPKColumnName} = v.${versionPKColumnName} " +
         "WHERE r.${releasePKColumnName} = ?1 " +
           "AND ${tableAlias}.${relationship|domain:Database|name}_id = ?2 ", nativeQuery = true)
    Long count${responseModelName}By${relationship.name|capitalize}Id(${releaseEntityPKAttribute.type|language} ${releaseEntityPKAttribute.name}, ${relationship.to.entity.primaryKey.type|language} ${relationship|domain|name}Id);

                $[/ if ]
            $[/ foreach ]
            $[ foreach relationship in entity.implicitRelationships ]
                $[ if relationship.to.entity.hasTag("internal:many-to-many") ]
                    $[ let destMMEntity = relationship.implicitToEntity ]
                    $[ let manyToManyEntity = relationship.to.entity ]
                    $[ let sourcePKType = entity.pkType|language ]
                    $[ let sourcePKVarName = entity.primaryKeyAttribute|domain|name ]
                    $[ let sourcePKDBName = entity.primaryKeyAttribute|domain:Database|name ]
                    $[ let destPKType = destMMEntity.pkType|language ]
                    $[ let destPKVarName = destMMEntity.primaryKeyAttribute|domain|name ]
                    $[ let destPKDBName = destMMEntity.primaryKeyAttribute|domain:Database|name ]
    @Query(value =
            "SELECT pt.* " +
            "FROM ${entity|domain:Database|name} pt " +
            "WHERE pt.${sourcePKDBName} IN " +
              "(SELECT ${sourcePKDBName} " +
                 "FROM ${manyToManyEntity|domain:Database|name} " +
                 "WHERE ${destPKDBName} = ?1) " +
             "ORDER BY pt.created_on DESC LIMIT ?3 OFFSET ?2", nativeQuery = true)
    List<${modelName}> get${modelName}ListAssociatedWith${destMMEntity|domain:Model|name}(${releaseEntityPKAttribute.type|language} ${releaseEntityPKAttribute.name}, ${destPKType} ${destPKVarName}, long start, int limit);

    @Query(value =
            "SELECT COUNT(pt.*) " +
            "FROM ${entity|domain:Database|name} pt " +
            "WHERE pt.${sourcePKDBName} IN " +
              "(SELECT ${sourcePKDBName} " +
                 "FROM ${manyToManyEntity|domain:Database|name} " +
                 "WHERE ${destPKDBName} = ?1) ", nativeQuery = true)
    Long count${modelName}By${destMMEntity|domain:Model|name}Id(${releaseEntityPKAttribute.type|language} ${releaseEntityPKAttribute.name}, ${destPKType} ${destPKVarName});
                $[/ if ]
            $[/ foreach ]
        $[/ author ]
    $[/ author ]
$[/ publisher ]