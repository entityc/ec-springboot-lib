$[version 0.5.0]
$[language java]
$[domain Service]
$[import "release/ReleaseFunctions"]
$[import "util/AutoWired"]

$[function addCacheDef(name, key, valueClass, definition)]
$[send caches]
$[if definition.isLRUType]
    private final LRUCache<${key}, ${valueClass}> ${name} = new LRUCache<>(${definition.size});
$[else]
$[log fatal]This template does not support a cache of type: ${definition.type.name}$[/log]
$[/if]
$[/send]
$[/function]

$[*
    Generate README.md file for all Services.
*]
$[file domain.namespace|path "README" "md"]
# Service Classes

The classes in this directory are Service classes as part of the Spring Framework.

## Generated by

Entity Compiler v${compiler.version}

Template: `${__template.name}` v${__template.version}

$[/file]
$[let exceptionNamespace = space.domain("Exception").namespace]
$[let serviceNamespace = space.domain("Service").namespace]
$[let utilsNamespace = space.domain("Utils").namespace]
$[*
    This is the core part of the template where it generates the Service classes.
*]
$[let useCache = true]
$[foreach space.modules]
$[if module.isIncluded]$[continue]$[/if]
$[foreach module.entities as entity]
$[if entity.isSecondary || entity.isImplicit || entity.isExtern || entity.isTransient]$[continue]$[/if]
$[let useSingleCache = useCache && entity.hasPrimaryKey && (entity|domain).hasCache]
$[let className = entity|domain|name]
$[let modelName = entity|domain:Model|name]
$[let modelVariableName = entity|domain:Model|name|uncapitalize]
$[let repositoryClassName = entity|domain:Repository|name]
$[let repositoryVariableName = entity|domain:Repository|name|uncapitalize]
$[let responseEntity = entity]
$[let responseDtoName = responseEntity|domain:JSONDTO|name]
$[let protobufNamespace = space.domain("ProtobufDTO").namespace]
$[let protobufClassName = entity|domain:ProtobufDTO|name]
$[capture fullProtobufClassName]${entity.module|domain:ProtobufDTO|name}.${protobufClassName}$[/capture]
$[let responseModelName = responseEntity|domain:Model|name]
$[file domain.namespace|path entity|domain|name "java"]
//
// This Service class is responsible for higher level functions for entity:
//
//   Name:        ${entity.name}
$[if entity.hasDescription]
//   Description: ${entity.description|wrap}
$[/if]
$[if entity.hasTags]
//   Tags:        [${entity.tagsSeparatedBy("][")}]
$[/if]
//
// THIS FILE IS GENERATED. DO NOT EDIT!!
//
package ${domain.namespace};

import ${serviceNamespace}.file.BinaryPersistence;
import ${serviceNamespace}.file.Metadata;
$[if useCache]
import ${utilsNamespace}.LRUCache;
$[/if]

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.dao.DataAccessException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import java.io.ByteArrayInputStream;

import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.Date;

import ${exceptionNamespace}.ServiceException;
import ${exceptionNamespace}.DaoException;
import ${exceptionNamespace}.EntityNotFoundException;

$[receive distinct imports]
$[send imports]
import ${entity|domain:Model|fullname};
import ${entity|domain:JSONDTO|fullname};
import ${protobufNamespace}.${entity.module.name|capitalize};
$[/send]

@Service
@Transactional
public class ${className} extends BaseService {

$[receive distinct repositoryDecl]
    @Autowired
    private BinaryPersistence binaryPersistence;

$[foreach entity.attributes]
$[if attribute.secondaryEntityIsTagged("asset:collection") || attribute.secondaryEntityIsTagged("asset:file")]
    @Value("${true ? "${aws.s3.bucket}" : ""}")
    private String bucketName;

$[break]
$[/if]
$[/foreach]
$[receive distinct caches]

$[if useCache]
$[if useSingleCache]
$[let primarykeyIdType = (entity.pkType|language)]
$[call addCacheDef(name:"modelCache", key:primarykeyIdType, valueClass: responseModelName, definition: (entity|domain).cache)]
$[call addCacheDef(name:"jsonCache", key:primarykeyIdType, valueClass: responseDtoName, definition: (entity|domain).cache)]
$[call addCacheDef(name:"protobufCache", key:primarykeyIdType, valueClass: fullProtobufClassName, definition: (entity|domain).cache)]
$[/if]
$[foreach entity.relationships]
$[if !relationship.isParent || relationship.isOptional]$[continue]$[/if]
$[let hasCache = (relationship.reverseRelationship|domain|has cache)]
$[if !hasCache]$[continue]$[/if]
    private final LRUCache<${relationship.to.entity.pkType|language}, List<${responseModelName}>> ${relationship.name}ListCache = new LRUCache<>(${(relationship.reverseRelationship|domain).cache.size});
$[/foreach]

$[/if]
    @Autowired
    public ${className}(
$[receive distinct constructorArgs]
    ) {
$[receive distinct constructorAssigns]
    }
$[let repositoryEntity = entity|domain:Repository]
$[let autoWiredDomainEntities = @[]@]
$[call addAutoWired(domainEntity:repositoryEntity)]

$[**********]
$[* CREATE *]
$[**********]
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public ${modelName} create${modelName}(${modelName} object) throws ServiceException {
$[if entity.hasPrimaryKey]
        object.setId(UUID.randomUUID());
$[/if]
        ${modelName} savedObject = this.save${entity.name}(object);
$[if useCache]
$[foreach entity.relationships]$[if !relationship.isParent || relationship.isOptional]$[continue]$[/if]
$[let hasCache = (relationship.reverseRelationship|domain|has cache)]
$[if !hasCache]$[continue]$[/if]
        ${relationship.name}ListCache.invalidate(object.get${relationship.name|capitalize}Id());
$[/foreach]
$[/if]
        return savedObject;
    }

$[*******************************]
$[* CREATE WITH (relationships) *]
$[*******************************]
$[if entity.hasPrimaryParentRelationship]
$[foreach entity.relationships]
$[if !relationship.to.isOne]$[continue]$[/if]
$[let toPrimaryKeyName = relationship.to.entity.primaryKeyAttribute.name]
$[if relationship.isParent && !relationship.isOptional]
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public ${modelName} create${modelName}With${relationship.name|capitalize}(${relationship.to.entity.pkType|language} ${toPrimaryKeyName}, ${modelName} object) throws ServiceException {
$[if entity.hasPrimaryKey]
        object.setId(UUID.randomUUID());
$[/if]
        object.set${relationship.name|capitalize}Id(${toPrimaryKeyName});
        ${modelName} savedObject = this.save${entity.name}(object);
        return savedObject;
    }

$[/if]
$[/foreach]
$[/if]
$[**********]
$[* UPDATE *]
$[**********]
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public ${modelName} update${entity.name}(${modelName} object) throws ServiceException {
        return save${entity.name}(object);
    }

$[********]
$[* SAVE *]
$[********]
$[let versionWithIsLock = false]
$[if entity.hasTag("release:version")]
$[let binderRelationship = entity.relationshipToEntityTagged("release:binder")]
$[if binderRelationship != null && binderRelationship.to.isMany]
$[let binderEntity = binderRelationship.to.entity]
$[let topReleaseRelationship = binderEntity.relationshipToEntityTagged("release:top")]
$[if topReleaseRelationship != null]
$[let topReleaseEntity = topReleaseRelationship.to.entity]
$[if topReleaseEntity.hasAttributeTagged("release:lock")]
$[let versionWithIsLock = true]
$[/if]$[/if]$[/if]$[/if]
    private ${modelName} save${entity.name}(${modelName} object) throws ServiceException {
        try {
$[if versionWithIsLock]
$[send imports]
import ${exceptionNamespace}.UnauthorizedException;
$[/send]
            Boolean isLocked = ${repositoryVariableName}.is${entity|domain:Model|name}Locked(object.getId());
            if (isLocked != null && isLocked) {
                throw new UnauthorizedException("The parent ${topReleaseEntity.name|words} object is locked.");
            }
$[elseif entity.hasTag("release:top") && entity.hasAttributeTagged("release:lock")]
$[let lockAttribute = entity.attributeTagged("release:lock")]
$[send imports]
import ${exceptionNamespace}.UnauthorizedException;
$[/send]
            if (object.getId() != null) {
                // throw an an exception if an attempt to modify a locked object.
                Optional<${responseModelName}> checkObjectOptional = ${repositoryVariableName}.findById(object.getId());
                if (checkObjectOptional.isPresent() && checkObjectOptional.get().is${lockAttribute|domain:Model|name|capitalize}()) {
                    throw new UnauthorizedException("This ${entity|name|words} object is locked.");
                }
            }
$[elseif entity.hasTag("release:binder") && entity.hasPrimaryParentRelationship && entity.primaryParentRelationship.to.entity.hasAttributeTagged("release:lock")]
$[send imports]
import ${exceptionNamespace}.UnauthorizedException;
import ${exceptionNamespace}.ValidationException;
$[/send]
$[let parentEntity = entity.primaryParentRelationship.to.entity]
$[let lockAttribute = parentEntity.attributeTagged("release:lock")]
$[if parentEntity.name != entity.name]
$[call addAutoWired(domainEntity:parentEntity|domain:Repository)]
$[send imports]
import ${parentEntity|domain:Model|fullname};
$[/send]
$[/if]
            if (object.get${entity.primaryParentRelationship|domain:Model|name|capitalize}Id() == null) {
                throw new ValidationException("Reference to the ${entity.primaryParentRelationship.to.entity.name|words} object was null.");
            }
            // need to throw an exception if the parent ${entity.primaryParentRelationship.to.entity.name} object is locked.
            Optional<${parentEntity|domain:Model|name}> parentObjectOptional = ${parentEntity|domain:Repository|name|uncapitalize}.findById(object.get${entity.primaryParentRelationship|domain:Model|name|capitalize}Id());
            if (parentObjectOptional.isPresent() && parentObjectOptional.get().is${lockAttribute|domain:Model|name|capitalize}()) {
                throw new UnauthorizedException("The parent ${parentEntity|name|words} object is locked.");
            }
$[/if]
            ${modelName} savedObject = ${repositoryVariableName}.save(object);
$[if useCache]
$[if useSingleCache]
            ${responseModelName} refetchedObject = ${repositoryVariableName}.get${responseModelName}ById(savedObject.getId());
            modelCache.put(savedObject.getId(), refetchedObject);
            jsonCache.invalidate(savedObject.getId());
            protobufCache.invalidate(savedObject.getId());
$[/if]
$[foreach entity.attributes]$[if !attribute.isParent]$[continue]$[/if]
$[let hasCache = (attribute|domain|has cache)]
$[if !hasCache]$[continue]$[/if]
            ${attribute.name}ListCache.invalidate(object.get${attribute.name|capitalize}());
$[/foreach]
$[foreach entity.relationships]$[if !relationship.isParent || relationship.isOptional]$[continue]$[/if]
$[let hasCache = (relationship.reverseRelationship|domain|has cache)]
$[if !hasCache]$[continue]$[/if]
            ${relationship.name}ListCache.invalidate(object.get${relationship.name|capitalize}Id());
$[/foreach]
$[/if]
            return savedObject;
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

$[***********************************************]
$[* JSONDTO FROM MODEL - POPULATE OBJECT FIELDS *]
$[***********************************************]
$[receive methodDescriptionReceiver]
    public ${responseDtoName} dtoFromModel(${responseModelName} modelObject, boolean hierarchical) throws ServiceException {
$[let _mapperDomainEntity = entity|domain:DTOMapper]
$[call addAutoWired(domainEntity:_mapperDomainEntity)]
$[let _mapperVariableName = _mapperDomainEntity|name|uncapitalize]
        ${responseDtoName} dtoObject = ${_mapperVariableName}.toDtoFromModel(modelObject);
$[let copiedEntities = @[]@]
        if (hierarchical) {
$[foreach (entity|domain:JSONDTO|view:APIGet).relationships|sort as relationship]
$[let _toEntity = relationship.to.entity]
$[if _toEntity.entity.isImplicit || _toEntity.entity.isExtern || _toEntity.entity.isIncluded]$[continue]$[/if]
$[let toSelf = _toEntity.entity.name == entity.name]
$[let includeChildEntities = (_toEntity.space.name == entity.space.name) && !_toEntity.isIncluded]
$[if !includeChildEntities]$[continue]$[/if]
$[let _toEntityDtoClassName = _toEntity|name]
$[let _toEntityModelClassName = _toEntity|domain:Model|name]
$[send imports]
import ${_toEntity|domain:Model|fullname};
import ${_toEntity|domain:JSONDTO|fullname};
$[/send]
$[call addAutoWired(domainEntity:_toEntity|domain:DTOMapper)]
$[let _toEntityMapperClassName = _toEntity|domain:DTOMapper|name]
$[let _toEntityMapperVariableName = _toEntityMapperClassName|uncapitalize]
$[let _toEntityRepository = _toEntity|domain:Repository]
$[if _toEntity.name != entity.name]
$[call addAutoWired(domainEntity:_toEntityRepository)]
$[/if]
$[if relationship.to.isOne && relationship.withViewName != "Reference" ]
$[do copiedEntities.add(relationship.to.entity)]
$[if !toSelf]
$[call addAutoWired(domainEntity:(_toEntity|domain:Service))]
$[/if]
            if (modelObject.get${relationship|domain:Model|name|capitalize}Id() != null) {
                Optional<${_toEntityModelClassName}> fieldObjectOptional = ${_toEntityRepository|name|uncapitalize}.findById(modelObject.get${relationship|domain:Model|name|capitalize}Id());
                if (!fieldObjectOptional.isPresent()) {
                    throw new EntityNotFoundException("${_toEntityModelClassName} not found.");
                }
                dtoObject.set${relationship|domain:Model|name|capitalize}($[if toSelf]this$[else]${_toEntity|domain:Service|name|uncapitalize}$[/if].dtoFromModel(fieldObjectOptional.get(), true));
$[*                //dtoObject.set${relationship|domain:Model|name|capitalize}(${_toEntityMapperVariableName}.toDtoFromModel(fieldObjectOptional.get()));*]
            }
$[elseif relationship.to.isMany && relationship.withViewName != "Reference"]
$[capture bySomething]By${entity|domain:Model|name|capitalize}$[/capture]
$[capture byArgument]modelObject.get${entity.primaryKeyAttribute|domain:Model|name|capitalize}(), $[/capture]
$[send imports]
import java.util.HashSet;
$[/send]
$[*if false]
            {
                List<${_toEntityModelClassName}> items = ${_toEntityRepository|name|uncapitalize}.get${_toEntity|domain:Model|name|capitalize}List${bySomething}(${byArgument}0, 10000);
                HashSet<${_toEntityDtoClassName}> dtoItems = new HashSet<>();
                for( ${_toEntityModelClassName} item : items ) {
                    dtoItems.add(${_toEntityMapperVariableName}.toDtoFromModel(item));
                }
                dtoObject.set${relationship|domain:Model|name|capitalize}(dtoItems);
            }
$[else*]
$[if !toSelf]
$[call addAutoWired(domainEntity:(_toEntity|domain:Service))]
$[/if]
            dtoObject.set${relationship|domain:Model|name|capitalize}(new HashSet<>($[if toSelf]this$[else]${_toEntity|domain:Service|name|uncapitalize}$[/if].get${_toEntity|domain:JSONDTO|name|capitalize}List${bySomething}(${byArgument}0, 10000, true)));
$[*/if*]
$[/if]
$[/foreach]
        }
        return dtoObject;
    }
$[capture methodDesc]
Creates a DTO object from a Model object.
$[if !copiedEntities.isEmpty()]It also includes full objects for referenced $[if copiedEntities.count == 1]entity $[else]entities $[/if]
$[foreach copiedEntities.values as ce]$[if ce#last]and $[/if]${ce|domain:Model|name}$[if !ce#last], $[/if]$[/foreach].
$[/if]
$[/capture]
$[send methodDescriptionReceiver]
    /**
     * ${methodDesc|join|wrap:("     * ")}
     * @param modelObject An object of entity ${responseModelName} that was fetched from the database.
     * @return A corresponding DTO object.
     * @throws EntityNotFoundException Thrown if a referenced object is not found.
     * @throws ServiceException Thrown if something else unexpected happens.
     */
$[/send]
    public ${responseDtoName} dtoFromModel(${responseModelName} modelObject) throws ServiceException {
        return dtoFromModel(modelObject, true);
    }

$[************************************************]
$[* PROTOBUF FROM MODEL - POPULATE OBJECT FIELDS *]
$[************************************************]
    public ${fullProtobufClassName} protobufFromModel(${responseModelName} modelObject, boolean hierarchical) throws ServiceException {
$[let _mapperDomainEntity = entity|domain:DTOMapper]
$[call addAutoWired(domainEntity:_mapperDomainEntity)]
$[let _mapperVariableName = _mapperDomainEntity|name|uncapitalize]
        ${fullProtobufClassName} pbObject = ${_mapperVariableName}.toProtobufFromModel(modelObject);
        ${fullProtobufClassName}.Builder builder = ${fullProtobufClassName}.newBuilder(pbObject);
        if (hierarchical) {
$[foreach (entity|domain:ProtobufDTO|view:APIGet).relationships|sort as relationship]
$[let _toEntity = relationship.to.entity]
$[let toSelf = _toEntity.entity.name == entity.name]
$[if _toEntity.entity.isImplicit || _toEntity.entity.isExtern || _toEntity.entity.isIncluded]$[continue]$[/if]
$[let includeChildEntities = (_toEntity.space.name == entity.space.name) && !_toEntity.isIncluded]
$[if !includeChildEntities]$[continue]$[/if]
$[let _toEntityDtoClassName = _toEntity|name]
$[let _toEntityModelClassName = _toEntity|domain:Model|name]
$[send imports]
import ${_toEntity|domain:Model|fullname};
$[/send]
$[call addAutoWired(domainEntity:_toEntity|domain:DTOMapper)]
$[let _toEntityMapperClassName = _toEntity|domain:DTOMapper|name]
$[let _toEntityMapperVariableName = _toEntityMapperClassName|uncapitalize]
$[let _toEntityRepository = _toEntity|domain:Repository]
$[if !toSelf]
$[call addAutoWired(domainEntity:_toEntityRepository)]
$[/if]
$[if relationship.to.isOne && relationship.withViewName != "Reference" ]
            if (modelObject.get${relationship|domain:Model|name|capitalize}Id() != null) {
                Optional<${_toEntityModelClassName}> fieldObject = ${_toEntityRepository|name|uncapitalize}.findById(modelObject.get${relationship|domain:Model|name|capitalize}Id());
                if (!fieldObject.isPresent()) {
                    throw new EntityNotFoundException("${_toEntityModelClassName} not found.");
                }
                builder.set${relationship|domain:Model|name|capitalize}($[if toSelf]this$[else]${_toEntity|domain:Service|name|uncapitalize}$[/if].protobufFromModel(fieldObject.get(), true));
$[*                builder.set${relationship|domain:Model|name|capitalize}(${_toEntityMapperVariableName}.toProtobufFromModel(fieldObject.get())); *]
            }
$[elseif relationship.to.isMany && relationship.withViewName != "Reference"]
$[capture bySomething]By${entity|domain:Model|name|capitalize}$[/capture]
$[capture byArgument]modelObject.get${entity.primaryKeyAttribute|domain:Model|name|capitalize}(), $[/capture]
$[send imports]
import java.util.HashSet;
$[/send]
$[if false]
            {
                List<${_toEntityModelClassName}> items = ${_toEntityRepository|name|uncapitalize}.get${_toEntity|domain:Model|name|capitalize}List${bySomething}(${byArgument}0, 10000);
                for( ${_toEntityModelClassName} item : items ) {
                    builder.add${relationship|domain:Model|name|capitalize}(${_toEntityMapperVariableName}.toProtobufFromModel(item));
                }
            }
$[else]
            builder.addAll${relationship|domain:Model|name|capitalize}($[if toSelf]this$[else]${_toEntity|domain:Service|name|uncapitalize}$[/if].get${_toEntity|domain:ProtobufDTO|name|capitalize}PBList${bySomething}(${byArgument}0, 10000, true).getItemList());
$[/if]
$[/if]
$[/foreach]
        }
        return builder.build();
    }
    public ${fullProtobufClassName} protobufFromModel(${responseModelName} modelObject) throws ServiceException {
        return protobufFromModel(modelObject, true);
    }

$[*************]
$[* GET BY ID *]
$[*************]
$[function makeGetByIdServiceMethod(responseDomain, entity, useCache, useSingleCache)]
$[let protobufClassName = entity|domain:ProtobufDTO|name]
$[capture fullProtobufClassName]${entity.module|domain:ProtobufDTO|name}.${protobufClassName}$[/capture]
$[let responseDtoName = entity|domain:JSONDTO|name]
$[let responseModelName = entity|domain:Model|name]
$[let responseClassName = responseDomain.name == "JSONDTO" ? responseDtoName : (responseDomain.name == "Model" ? responseModelName : fullProtobufClassName)]
$[let responseInMethodName = responseDomain.name == "JSONDTO" ? responseDtoName : (responseDomain.name == "Model" ? responseModelName : (protobufClassName + "PB"))]
$[let repositoryVariableName = entity|domain:Repository|name|uncapitalize]
$[send imports]
import ${entity|domain:Model|fullname};
$[/send]
$[let pkidtype = (entity.pkType|language)]
$[let pkidname = (entity.primaryKeyAttribute|domain:Service|name)]
    public ${responseClassName} get${responseInMethodName}ById(${pkidtype} id) throws ServiceException {
        try {
            ${responseClassName} responseObject = null;
$[let indent = ""]
$[if useCache && useSingleCache]
$[if responseDomain.name == "JSONDTO"]
$[let cacheVariableName = "jsonCache"]
$[elseif responseDomain.name == "Model"]
$[let cacheVariableName = "modelCache"]
$[else]
$[let cacheVariableName = "protobufCache"]
$[/if]
            // check the cache first
            if (${cacheVariableName}.containsKey(id)) {
                responseObject = ${cacheVariableName}.get(id);
            } else {
$[let indent = "    "]
$[/if]

            ${indent}Optional<${responseModelName}> modelObjectOptional = ${repositoryVariableName}.findById(id);
            ${indent}if (!modelObjectOptional.isPresent()) {
            ${indent}    throw new EntityNotFoundException("${responseModelName} not found.");
            ${indent}}

            ${indent}${responseModelName} modelObject = modelObjectOptional.get();
$[if responseDomain.name == "JSONDTO"]
            ${indent}responseObject = dtoFromModel(modelObject);
$[elseif responseDomain.name == "Model"]
            ${indent}responseObject = modelObject;
$[else]
            ${indent}responseObject = protobufFromModel(modelObject);
$[/if]

$[if useCache && useSingleCache]
$[if entity.hasTag("release:top") && entity.hasAttributeTagged("release:lock")]
$[let lockAttribute = entity.attributeTagged("release:lock")]
$[/if]
$[let indent2 = ""]
$[if lockAttribute != null]
                if (modelObject.is${lockAttribute|domain:Model|name|capitalize}()) {
$[let indent2 = indent]
$[/if]
                ${indent2}${cacheVariableName}.put(modelObject.getId(), responseObject);
$[if lockAttribute != null]
                }
$[/if]
            }
$[/if]
            return responseObject;
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

$[/function]
$[if entity.hasPrimaryKey]
$[call makeGetByIdServiceMethod(responseDomain:space.domain("Model"))]
$[call makeGetByIdServiceMethod(responseDomain:space.domain("JSONDTO"))]
$[call makeGetByIdServiceMethod(responseDomain:space.domain("ProtobufDTO"))]
$[/if]
$[************]
$[* GET LIST *]
$[************]
$[let hasLockAttribute = entity.hasAttributeTagged("release:lock")]
$[let lockedDeclInsert = ""]
$[if hasLockAttribute]
$[let lockedDeclInsert = "boolean lockedOnly, "]
$[let lockAttribute = entity.attributeTagged("release:lock")]
$[/if]
    public List<${responseModelName}> get${responseModelName}List(${lockedDeclInsert}long start, int limit) throws ServiceException {
        try {
$[if hasLockAttribute]
            if (lockedOnly) {
                return ${repositoryVariableName}.getLocked${responseModelName}List(start, limit);
            } else {
                return ${repositoryVariableName}.get${responseModelName}List(start, limit);
            }
$[else]
            return ${repositoryVariableName}.get${responseModelName}List(start, limit);
$[/if]
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

    public List<${responseDtoName}> get${responseDtoName}List(${lockedDeclInsert}long start, int limit, boolean hierarchical) throws ServiceException {
        try {
            List<${responseDtoName}> dtoList = new ArrayList<>();
$[if hasLockAttribute]
            List<${responseModelName}> list;
            if (lockedOnly) {
                list = ${repositoryVariableName}.getLocked${responseModelName}List(start, limit);
            } else {
                list = ${repositoryVariableName}.get${responseModelName}List(start, limit);
            }
$[else]
            List<${responseModelName}> list = ${repositoryVariableName}.get${responseModelName}List(start, limit);
$[/if]
            for(${responseModelName} modelObject : list) {
                dtoList.add(dtoFromModel(modelObject, hierarchical));
            }
            return dtoList;
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

    public ${fullProtobufClassName}List get${protobufClassName}PBList(${lockedDeclInsert}long start, int limit, boolean hierarchical) throws ServiceException {
        try {
            ${fullProtobufClassName}List.Builder pbList = ${fullProtobufClassName}List.newBuilder();
$[if hasLockAttribute]
            List<${responseModelName}> list;
            if (lockedOnly) {
                list = ${repositoryVariableName}.getLocked${responseModelName}List(start, limit);
            } else {
                list = ${repositoryVariableName}.get${responseModelName}List(start, limit);
            }
$[else]
            List<${responseModelName}> list = ${repositoryVariableName}.get${responseModelName}List(start, limit);
$[/if]
            for(${responseModelName} modelObject : list) {
                pbList.addItem(protobufFromModel(modelObject, hierarchical));
            }
            return pbList.build();
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

$[****************************]
$[* GET LIST BY (attributes) *]
$[****************************]
$[function makeGetListByAttributeMethod(responseVariant, entity, attribute, useCache)]
$[let protobufClassName = entity|domain:ProtobufDTO|name]
$[capture fullProtobufClassName]${entity.module|domain:ProtobufDTO|name}.${protobufClassName}$[/capture]
$[let repositoryVariableName = entity|domain:Repository|name|uncapitalize]
$[let responseModelName = entity|domain:Model|name]
$[let responseDtoName = entity|domain:JSONDTO|name]
$[let isDtoVariant = responseVariant.name == "JSONDTO"]
$[let isModelVariant = responseVariant.name == "Model"]
$[let isPBVariant = responseVariant.name == "ProtobufDTO"]
$[let responseClassName = isDtoVariant ? responseDtoName : isModelVariant ? responseModelName : fullProtobufClassName]
$[let responseInMethodName = isDtoVariant ? responseDtoName : isModelVariant ? responseModelName : (protobufClassName + "PB")]
$[capture fullResponseName]$[if isPBVariant]${responseClassName}List$[else]List<${responseClassName}>$[/if]$[/capture]
    public ${fullResponseName} get${responseInMethodName}ListBy${attribute.name|capitalize}(
        ${attribute.type|language} ${attribute.name},
        long start,
        int limit,
        boolean hierarchical) throws ServiceException {

        try {
$[let listName = "list"]
$[if isDtoVariant]
$[let listName = "dtoList"]
            List<${responseDtoName}> dtoList = new ArrayList<>();
$[elseif isPBVariant]
$[let listName = "pbList"]
            ${fullProtobufClassName}List.Builder pbList = ${fullProtobufClassName}List.newBuilder();
$[/if]
            List<${responseModelName}> list = ${repositoryVariableName}.get${responseModelName}ListBy${attribute.name|capitalize}(${attribute.name}, start, limit);
$[if isDtoVariant || isPBVariant]
            for(${responseModelName} modelObject : list) {
$[if isDtoVariant]
                ${listName}.add(dtoFromModel(modelObject, hierarchical));
$[else]
                ${listName}.addItem(protobufFromModel(modelObject, hierarchical));
$[/if]
            }
$[/if]
$[if isPBVariant]
            return ${listName}.build();
$[else]
            return ${listName};
$[/if]
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

$[/function]
$[foreach entity.attributes]
$[if !attribute.isParent]$[continue]$[/if]
$[if attribute.type.isEnumType]
$[send imports]
import ${attribute.type|domain:Model|fullname};
$[/send]
$[/if]
$[call makeGetListByAttributeMethod(responseVariant:space.domain("Model"))]
$[call makeGetListByAttributeMethod(responseVariant:space.domain("JSONDTO"))]
$[call makeGetListByAttributeMethod(responseVariant:space.domain("ProtobufDTO"))]
$[/foreach]
$[*******************************]
$[* GET LIST BY (relationships) *]
$[*******************************]
$[function makeGetListByRelationshipMethod(responseVariant,entity,relationship, useCache)]
$[let protobufClassName = entity|domain:ProtobufDTO|name]
$[capture fullProtobufClassName]${entity.module|domain:ProtobufDTO|name}.${protobufClassName}$[/capture]
$[let isDtoVariant = responseVariant.name == "JSONDTO"]
$[let isModelVariant = responseVariant.name == "Model"]
$[let isPBVariant = responseVariant.name == "ProtobufDTO"]
$[let repositoryVariableName = entity|domain:Repository|name|uncapitalize]
$[let responseModelName = entity|domain:Model|name]
$[let responseDtoName = entity|domain:JSONDTO|name]
$[let responseClassName = isDtoVariant ? responseDtoName : isModelVariant ? responseModelName : fullProtobufClassName]
$[let responseInMethodName = isDtoVariant ? responseDtoName : isModelVariant ? responseModelName : (protobufClassName + "PB")]
$[let toPrimaryKeyName = relationship.to.entity.primaryKeyAttribute.name]
$[capture fullResponseName]$[if isPBVariant]${responseClassName}List$[else]List<${responseClassName}>$[/if]$[/capture]
    public ${fullResponseName} get${responseInMethodName}ListBy${relationship.name|capitalize}(
        ${relationship.to.entity.pkType|language} ${toPrimaryKeyName},
        long start,
        int limit,
        boolean hierarchical) throws ServiceException {

        try {
$[let listName = "list"]
$[if isDtoVariant]
$[let listName = "dtoList"]
            List<${responseDtoName}> dtoList = new ArrayList<>();
$[elseif isPBVariant]
$[let listName = "pbList"]
            ${fullProtobufClassName}List.Builder pbList = ${fullProtobufClassName}List.newBuilder();
$[/if]
            List<${responseModelName}> list = ${repositoryVariableName}.get${responseModelName}ListBy${relationship.name|capitalize}(${toPrimaryKeyName}, start, limit);
$[if isDtoVariant || isPBVariant]
            for(${responseModelName} modelObject : list) {
$[if isDtoVariant]
                ${listName}.add(dtoFromModel(modelObject, hierarchical));
$[else]
                ${listName}.addItem(protobufFromModel(modelObject));
$[/if]
            }
$[/if]
$[if isPBVariant]
            return ${listName}.build();
$[else]
            return ${listName};
$[/if]
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

$[/function]
$[foreach entity.relationships]
$[if !relationship.isParent]$[continue]$[/if]
$[call makeGetListByRelationshipMethod(responseVariant:space.domain("Model"))]
$[call makeGetListByRelationshipMethod(responseVariant:space.domain("JSONDTO"))]
$[call makeGetListByRelationshipMethod(responseVariant:space.domain("ProtobufDTO"))]
$[/foreach]
$[****************]
$[* BATCH DELETE *]
$[****************]
$[if entity.hasParentRelationship]
$[foreach entity.relationships]$[if !relationship.isParent]$[continue]$[/if]
    public void delete${modelName}By${relationship.name|capitalize}Id(${relationship.to.entity.pkType|language} ${relationship.name}Id) throws ServiceException {
        try {
$[if entity.hasTag("release:binder") && entity.hasPrimaryParentRelationship && entity.primaryParentRelationship.to.entity.hasAttributeTagged("release:lock")]
            // need to throw an exception if the parent ${entity.primaryParentRelationship.to.entity.name} object is locked.
$[let parentEntity = entity.primaryParentRelationship.to.entity]
$[let lockAttribute = parentEntity.attributeTagged("release:lock")]
$[call addAutoWired(domainEntity:parentEntity|domain:Repository)]
$[send imports]
import ${exceptionNamespace}.UnauthorizedException;
$[/send]
            Optional<${parentEntity|domain:Model|name}> parentObjectOptional = ${parentEntity|domain:Repository|name|uncapitalize}.findById(${relationship.name}Id);
            if (parentObjectOptional.isPresent() && parentObjectOptional.get().is${lockAttribute|domain:Model|name|capitalize}()) {
                throw new UnauthorizedException("The parent ${parentEntity|name|words} object is locked.");
            }
$[/if]
            ${repositoryVariableName}.delete${modelName}By${relationship.name|capitalize}Id(${relationship.name}Id);
$[if useCache]
$[foreach entity.relationships]$[if !relationship.isParent || relationship.isOptional]$[continue]$[/if]
$[let hasCache = (relationship.reverseRelationship|domain|has cache)]
$[if !hasCache]$[continue]$[/if]
            ${relationship.name}ListCache.invalidate(${relationship.name}Id);
$[/foreach]
$[/if]
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

$[/foreach]
$[/if]
$[****************]
$[* DELETE BY ID *]
$[****************]
$[if entity.hasPrimaryKey]
$[let pkidtype = (entity.pkType|language)]
$[let pkidname = (entity.primaryKeyAttribute|domain|name)]
    public void delete${modelName}ById(${pkidtype} id) throws ServiceException {
        try {
$[if entity.hasTag("release:binder") && entity.hasPrimaryParentRelationship && entity.primaryParentRelationship.to.entity.hasAttributeTagged("release:lock")]
            // need to throw an exception if the parent ${entity.primaryParentRelationship.to.entity.name} object is locked.
$[let parentEntity = entity.primaryParentRelationship.to.entity]
$[let lockAttribute = parentEntity.attributeTagged("release:lock")]
$[call addAutoWired(domainEntity:parentEntity|domain:Repository)]
$[send imports]
import ${exceptionNamespace}.UnauthorizedException;
$[/send]
            Optional<${entity|domain:Model|name}> objectOptional = ${repositoryVariableName}.findById(id);
            if (objectOptional.isPresent()) {
                Optional<${parentEntity|domain:Model|name}> parentObjectOptional = ${parentEntity|domain:Repository|name|uncapitalize}.findById(objectOptional.get().get${entity.primaryParentRelationship|domain:Model|name|capitalize}Id());
                if (parentObjectOptional.isPresent() && parentObjectOptional.get().is${lockAttribute|domain:Model|name|capitalize}()) {
                    throw new UnauthorizedException("The parent ${parentEntity|name|words} object is locked.");
                }
            } else {
                throw new EntityNotFoundException("The specified ${entity|name|words} object was not found.");
            }
$[/if]
$[if useCache]
            ${modelName} object = ${repositoryVariableName}.get${modelName}ById(id);
$[/if]
            ${repositoryVariableName}.deleteById(id);
$[if useCache]
$[foreach entity.relationships]$[if !relationship.isParent || relationship.isOptional]$[continue]$[/if]
$[let hasCache = (relationship.reverseRelationship|domain|has cache)]
$[if !hasCache]$[continue]$[/if]
            ${relationship.name}ListCache.invalidate(object.get${relationship.name|capitalize}Id());
$[/foreach]
$[/if]
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

$[/if]
$[****************]
$[* UPLOAD  OLD  *]
$[****************]
$[foreach entity.attributes]
$[if !attribute.type.isAssetType]$[continue]$[/if]
$[let attributeNameCapitalized = (attribute|domain:Model|name|capitalize)]
    public void upload${attribute|domain:Model|name|capitalize}(${modelName} ${modelVariableName}, String contentType, byte[] dataArray, String fileExtension) throws ServiceException {
$[* WE SHOULD DO THIS FOR IMAGES TO VALIDATE AGAINST CONSTRAINTS
        BufferedImage img = ImageUtils.createBufferedImage(imageByteArray);

        ClubImageType imageType = imageTypeRepository.findById(type).orElseThrow(() -> new ValidationException(ClubMessages.TYPE_NOT_DEFINED));
        if (imageType.getWidth() != img.getWidth() || imageType.getHeight() != img.getHeight()) {
            throw new ValidationException(ClubMessages.WRONG_IMAGE_SIZE);
        }
*]
        final ByteArrayInputStream is = new ByteArrayInputStream(dataArray);
        final Metadata metadata = new Metadata(dataArray.length, contentType);

        final String filename = "${entity|domain:APIPath|name}/" + ${modelVariableName}.get${entity.primaryKeyAttribute|domain:Model|name|capitalize}() + "/${attribute|domain:Model|name}" + (fileExtension != null ? ("." + fileExtension) : "");

        binaryPersistence.save(bucketName, filename, is, metadata);

        ${modelVariableName}.set${attributeNameCapitalized}BucketName(bucketName);
        ${modelVariableName}.set${attributeNameCapitalized}Path(filename);
        ${modelVariableName}.set${attributeNameCapitalized}Url(binaryPersistence.getUrl(bucketName, filename));
        save${modelName}(${modelVariableName});
    }

$[/foreach]
$[****************]
$[*    UPLOAD    *]
$[****************]
$[function uploadAssetFile(entity, collectionAttribute, attribute, modelName, modelVariableName)]
$[let hasCollection = collectionAttribute != null]
$[if hasCollection]
$[let collectionName = collectionAttribute|domain:Model|name]
$[/if]
$[if attribute.secondaryEntityIsTagged("asset:file")]
$[let secondaryAttributeEntity = attribute.getTypeEntity()]
$[let secondaryAttributeEntityClassName = secondaryAttributeEntity|domain:Model|name]
$[let includeHash = secondaryAttributeEntity.hasTag("hashed") && secondaryAttributeEntity.hasAttributeTagged("md5")]
$[let attributeNameCapitalized = (attribute|domain:Model|name|capitalize)]
$[let methodName = attribute|domain:Model|name|capitalize]
$[if hasCollection]
$[capture methodName]${collectionName|capitalize}${methodName}$[/capture]
$[/if]
    public void upload${methodName}(${modelName} ${modelVariableName}, String contentType, byte[] dataArray, String fileExtension) throws ServiceException {
$[* TODO: Handle constraints here *]
        final ByteArrayInputStream is = new ByteArrayInputStream(dataArray);
        final Metadata metadata = new Metadata(dataArray.length, contentType);
$[let assetName = attribute|domain:Model|name]
$[if hasCollection]
$[capture assetName]${collectionName}-${assetName}$[/capture]
$[/if]
        final String filename = "${entity|domain:APIPath|name}/" + ${modelVariableName}.get${entity.primaryKeyAttribute|domain:Model|name|capitalize}() + "/${assetName}" + (fileExtension != null ? ("." + fileExtension) : "");

        binaryPersistence.save(bucketName, filename, is, metadata);

$[send imports]
import ${secondaryAttributeEntity|domain:Model|fullname};
$[/send]
        ${secondaryAttributeEntityClassName} asset = new ${secondaryAttributeEntityClassName}();
$[if secondaryAttributeEntity.hasAttributeTagged("url")]
        asset.set${secondaryAttributeEntity.attributeTagged("url")|name|capitalize}(binaryPersistence.getUrl(bucketName, filename));
$[/if]
$[if secondaryAttributeEntity.hasAttributeTagged("path")]
        asset.set${secondaryAttributeEntity.attributeTagged("path")|name|capitalize}(filename);
$[/if]
$[if secondaryAttributeEntity.hasAttributeTagged("bucketName")]
        asset.set${secondaryAttributeEntity.attributeTagged("bucketName")|name|capitalize}(bucketName);
$[/if]
$[if secondaryAttributeEntity.hasAttributeTagged("size")]
        asset.set${secondaryAttributeEntity.attributeTagged("size")|name|capitalize}(dataArray.length);
$[/if]
$[if includeHash]
$[send imports]
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
$[/send]
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] md5digest = md.digest(dataArray);
            asset.set${secondaryAttributeEntity.attributeTagged("md5")|name|capitalize}(md5digest);
        } catch (NoSuchAlgorithmException e) {
            throw new ServiceException("Not able to obtain MD5 message digest function.");
        }
$[/if]
$[if hasCollection]
$[let collectionEntity = attribute.entity]
$[send imports]
import ${collectionEntity|domain:Model|fullname};
$[/send]
        if (${modelVariableName}.get${collectionName|capitalize}() == null) {
            ${modelVariableName}.set${collectionName|capitalize}(new ${collectionEntity|domain:Model|name}());
        }
        ${modelVariableName}.get${collectionName|capitalize}().set${attribute|domain:Model|name|capitalize}(asset);
$[else]
        ${modelVariableName}.set${attribute|domain:Model|name|capitalize}(asset);
$[/if]

        save${modelName}(${modelVariableName});
    }

$[/if]
$[/function]
$[foreach entity.attributes as attribute]
$[if attribute.secondaryEntityIsTagged("asset:collection")]
$[let secondaryAttributeEntity = attribute.getTypeEntity()]
$[foreach secondaryAttributeEntity.attributes as secondaryAttribute]
$[call uploadAssetFile(attribute:secondaryAttribute, collectionAttribute:attribute)]
$[/foreach]
$[else]
$[call uploadAssetFile(attribute:attribute, collectionAttribute:null)]
$[/if]
$[/foreach]
$[*******************]
$[*     RELEASE     *]
$[*******************]
$[call lookForReleaseStructure(topReleaseEntity:entity) -> (results:releaseStructure)]
$[if releaseStructure != null]
$[*
    CLEAR RELEASE
    Deletes all linked element versions from a release.
*]
    public void clearRelease(UUID releaseId) throws ServiceException {
$[foreach releaseStructure.values as rs]
$[let binderEntity = rs.get(0)]
$[let repositoryDomainEntity = binderEntity|domain:Repository]
$[let repositoryVariableName = repositoryDomainEntity|name|uncapitalize]
$[call addAutoWired(domainEntity: repositoryDomainEntity)]
        ${repositoryVariableName}.delete${binderEntity.name}By${binderEntity.singleParentRelationship.name|capitalize}Id(releaseId);
$[/foreach]
    }

$[*
    POPULATE WITH LATEST
    This populates the release with the latest versions of all elements associated with a release.
*]
$[let sentObjectParentPK = false]
$[let extraIdVarName = null]
$[let extraIdDecl = null]
    private void populateReleaseWithLatestVersions(UUID releaseId$[receive distinct objectParentPKDecl]) throws ServiceException {
$[foreach releaseStructure.values as rs]
$[let binderEntity = rs.get(0)]
$[let objectEntity = rs.get(1)]
$[let versionedEntity = rs.get(2)]
$[let repositoryDomainEntity = versionedEntity|domain:Repository]
$[let repositoryVariableName = repositoryDomainEntity|name|uncapitalize]
$[send imports]
import ${versionedEntity|domain:Model|fullname};
import ${binderEntity|domain:Model|fullname};
$[/send]
$[call addAutoWired(domainEntity: repositoryDomainEntity)]
$[let objectParentEntity = objectEntity.primaryParentRelationship.to.entity]
$[if objectParentEntity != null]
$[call hasRelationshipWithEntityTagged(fromEntity:objectParentEntity, tag:"release:top") -> (result:hasRelationshipWithReleaseTop)]
$[if !hasRelationshipWithReleaseTop]
$[let objectParentEntity = null]
$[/if]
$[/if]
$[let nvpePrimaryKeyAttr = null]
$[let nvpePrimaryKeyAttributeDomainName = ""]
$[let methodNameSuffix = ""]
$[if objectParentEntity != null]
$[let nvpePrimaryKeyAttr = objectParentEntity.primaryKeyAttribute]
$[let nvpePrimaryKeyAttributeDomainName = nvpePrimaryKeyAttr|domain|name|uncapitalize]
$[capture methodNameSuffix]For${objectParentEntity.name}$[/capture]
$[if !sentObjectParentPK]
$[capture extraIdVarName], ${nvpePrimaryKeyAttr|domain|name}$[/capture]
$[capture extraIdDecl], ${nvpePrimaryKeyAttr.type|language} ${nvpePrimaryKeyAttr|domain|name}$[/capture]
$[send objectParentPKDecl]${extraIdDecl}$[/send]
$[let sentObjectParentPK = true]
$[/if]
$[/if]
        {
            List<${versionedEntity|domain:Model|name}> versions = ${repositoryVariableName}.getLatestVersions${methodNameSuffix}(${nvpePrimaryKeyAttributeDomainName});
            for(${versionedEntity|domain:Model|name} version : versions) {
                ${binderEntity|domain:Model|name} release = new ${binderEntity|domain:Model|name}();
                release.set${objectEntity.primaryKeyAttribute|domain|name|capitalize}(version.get${objectEntity.primaryKeyAttribute|domain|name|capitalize}());
                release.set${versionedEntity.primaryKeyAttribute|domain|name|capitalize}(version.get${versionedEntity.primaryKeyAttribute|domain:Model|name|capitalize}());
                release.set${binderEntity.singleParentRelationship.to.entity|domain:Model|name}Id(releaseId);
$[call addAutoWired(domainEntity: binderEntity|domain:Service)]
                ${binderEntity|domain:Service|name|uncapitalize}.create${binderEntity|domain:Model|name}(release);
            }
        }
$[/foreach]
    }

    public void resetReleaseToLatestVersions(UUID releaseId${extraIdDecl}) throws ServiceException {
        clearRelease(releaseId);
        populateReleaseWithLatestVersions(releaseId${extraIdVarName});
    }

$[*
    POPULATE FROM ANOTHER RELEASE
    This populates the release with another release.
*]
$[let sentObjectParentPK = false]
$[let extraIdVarName = null]
$[let extraIdDecl = null]
    private void populateReleaseWithRelease(UUID releaseId, UUID fromReleaseId$[receive distinct objectParentPKDecl]) throws ServiceException {
$[foreach releaseStructure.values as rs]
$[let binderEntity = rs.get(0)]
$[let objectEntity = rs.get(1)]
$[let versionedEntity = rs.get(2)]
$[let repositoryDomainEntity = binderEntity|domain:Repository]
$[let repositoryVariableName = repositoryDomainEntity|name|uncapitalize]
$[send imports]
import ${versionedEntity|domain:Model|fullname};
import ${binderEntity|domain:Model|fullname};
$[/send]
$[call addAutoWired(domainEntity: repositoryDomainEntity)]
$[let objectParentEntity = objectEntity.primaryParentRelationship.to.entity]
$[if objectParentEntity != null]
$[call hasRelationshipWithEntityTagged(fromEntity:objectParentEntity, tag:"release:top") -> (result:hasRelationshipWithReleaseTop)]
$[if !hasRelationshipWithReleaseTop]
$[let objectParentEntity = null]
$[/if]
$[/if]
$[let nvpePrimaryKeyAttr = null]
$[let nvpePrimaryKeyAttributeDomainName = ""]
$[let methodNameSuffix = ""]
$[if objectParentEntity != null]
$[let nvpePrimaryKeyAttr = objectParentEntity.primaryKeyAttribute]
$[let nvpePrimaryKeyAttributeDomainName = nvpePrimaryKeyAttr|domain|name|uncapitalize]
$[capture methodNameSuffix]For${objectParentEntity.name}$[/capture]
$[if !sentObjectParentPK]
$[capture extraIdVarName], ${nvpePrimaryKeyAttr|domain|name}$[/capture]
$[capture extraIdDecl], ${nvpePrimaryKeyAttr.type|language} ${nvpePrimaryKeyAttr|domain|name}$[/capture]
$[send objectParentPKDecl]${extraIdDecl}$[/send]
$[let sentObjectParentPK = true]
$[/if]
$[/if]
        {
            List<${binderEntity|domain:Model|name}> versionReleases = ${repositoryVariableName}.get${binderEntity|domain:Model|name}ListBy${entity|domain:Model|name}(fromReleaseId, 0, Integer.MAX_VALUE);
            for(${binderEntity|domain:Model|name} versionRelease : versionReleases) {
                ${binderEntity|domain:Model|name} release = new ${binderEntity|domain:Model|name}();
                release.set${objectEntity.primaryKeyAttribute|domain|name|capitalize}(versionRelease.get${objectEntity.primaryKeyAttribute|domain|name|capitalize}());
                release.set${versionedEntity.primaryKeyAttribute|domain|name|capitalize}(versionRelease.get${versionedEntity.primaryKeyAttribute|domain|name|capitalize}());
                release.set${binderEntity.singleParentRelationship.to.entity|domain:Model|name}Id(releaseId);
$[call addAutoWired(domainEntity: binderEntity|domain:Service)]
                ${binderEntity|domain:Service|name|uncapitalize}.create${binderEntity|domain:Model|name}(release);
            }
        }
$[/foreach]
    }

    public void resetReleaseWithOtherRelease(UUID releaseId, UUID fromReleaseId${extraIdDecl}) throws ServiceException {
        clearRelease(releaseId);
        populateReleaseWithRelease(releaseId, fromReleaseId${extraIdVarName});
    }

$[/if]
$[foreach entity.implicitRelationships as relationship]
$[if relationship.to.entity.hasTag("internal:many-to-many")]
$[let manyToManyEntity = relationship.to.entity]
$[let destMMEntity = null]
$[foreach manyToManyEntity.implicitRelationships as mmRel]
$[if mmRel.to.entity.name != entity.name]
$[let destMMEntity = mmRel.to.entity]
$[break];
$[/if]
$[/foreach]
$[let destModelName = destMMEntity|domain:Model|name]
$[let destRepoEntityName = destMMEntity|domain:Repository|name]
$[let destRepoVarName = destRepoEntityName|uncapitalize]
$[let sourcePKType = entity.pkType|language]
$[let sourcePKVarName = entity.primaryKeyAttribute|domain|name]
$[let destPKType = destMMEntity.pkType|language]
$[let destPKVarName = destMMEntity.primaryKeyAttribute|domain|name]
$[send imports]
import ${destMMEntity|domain:Model|fullname};
$[/send]
$[call addAutoWired(domainEntity:destMMEntity|domain:Repository)]
    public void associateTo${destModelName}(${sourcePKType} ${sourcePKVarName}, ${destPKType} ${destPKVarName}) throws ServiceException {
        Optional<${modelName}> modelObjectOptional = ${repositoryVariableName}.findById(${sourcePKVarName});
        if (!modelObjectOptional.isPresent()) {
            throw new EntityNotFoundException("${modelName} not found.");
        }

        Optional<${destModelName}> otherModelObjectOptional = ${destRepoVarName}.findById(${destPKVarName});
        if (!otherModelObjectOptional.isPresent()) {
            throw new EntityNotFoundException("${destModelName} not found.");
        }
        if (!${repositoryVariableName}.isAssociatedTo${destModelName}(${sourcePKVarName}, ${destPKVarName}) ) {
            ${repositoryVariableName}.addAssociationTo${destModelName}(${sourcePKVarName}, ${destPKVarName});
        }
    }
$[/if]
$[/foreach]
}
$[/file]
$[/foreach]
$[/foreach]
