$[ D summary, main "This template contains the authors that are responsible for generating the get object" ]
$[ D summary, main "service methods." ]
$[ D "This includes methods for getting not just a single object but lists of objects." ]
$[ publisher org.entityc.springboot.service.get ]
    $[ import "util/AutoWired" ]
    $[ author to org.entityc.springboot.service ]
        $[ author to outlet methods ]
$[ outlet init
   D "Used by authors that may want to initialize some variables before using the other outlets."
]
$[/ outlet ]
            $[ let exceptionNamespace = (space.domain("Exception")).namespace ]
$[ send imports ]
import ${exceptionNamespace}.ServiceException;
import ${exceptionNamespace}.DaoException;
import ${exceptionNamespace}.EntityNotFoundException;
import java.util.List;
import java.util.ArrayList;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.Date;
$[/ send ]
            $[ let responseDtoName = entity|domain:JSONDTO|name ]
            $[ let responseModelName = entity|domain:Model|name ]
            $[ let repositoryVariableName = entity|domain:Repository|name|uncapitalize ]
$[*************]
$[* GET BY ID *]
$[*************]
            $[ function makeGetByIdServiceMethod
               (responseDomain,
                entity,
                useCache,
                useSingleCache
               ) ]
                $[ let protobufClassName = entity|domain:ProtobufDTO|name ]
                $[ capture fullProtobufClassName ]${entity.module|domain:ProtobufDTO|name}.${protobufClassName}$[/ capture ]
                $[ let responseDtoName = entity|domain:JSONDTO|name ]
                $[ let responseModelName = entity|domain:Model|name ]
                $[ let responseClassName = responseDomain.name == "JSONDTO" ? responseDtoName:responseDomain.name == "Model" ? responseModelName:fullProtobufClassName ]
                $[ let responseInMethodName = responseDomain.name == "JSONDTO" ? responseDtoName:responseDomain.name == "Model" ? responseModelName:protobufClassName + "PB" ]
                $[ let repositoryVariableName = entity|domain:Repository|name|uncapitalize ]
                $[ let pkidtype = entity.pkType|language ]
                $[ let pkidname = entity.primaryKeyAttribute|domain:Service|name ]
    public ${responseClassName} get${responseInMethodName}ById(${pkidtype} id) throws ServiceException {
        try {
            ${responseClassName} responseObject = null;
                $[ let indent = "" ]
                $[ if useCache && useSingleCache ]
                    $[ if responseDomain.name == "JSONDTO" ]
                        $[ let cacheVariableName = "jsonCache" ]
                    $[ elseif responseDomain.name == "Model" ]
                        $[ let cacheVariableName = "modelCache" ]
                    $[ else ]
                        $[ let cacheVariableName = "protobufCache" ]
                    $[/ if ]
            // check the cache first
            if (${cacheVariableName}.containsKey(id)) {
                responseObject = ${cacheVariableName}.get(id);
            } else {
                    $[ let indent = "    " ]
                $[/ if ]

            ${indent}Optional<${responseModelName}> modelObjectOptional = ${repositoryVariableName}.findById(id);
            ${indent}if (!modelObjectOptional.isPresent()) {
            ${indent}    throw new EntityNotFoundException("${responseModelName} not found.");
            ${indent}}

            ${indent}${responseModelName} modelObject = modelObjectOptional.get();
                $[ if responseDomain.name == "JSONDTO" ]
            ${indent}responseObject = dtoFromModel(modelObject);
                $[ elseif responseDomain.name == "Model" ]
            ${indent}responseObject = modelObject;
                $[ else ]
            ${indent}responseObject = protobufFromModel(modelObject);
                $[/ if ]

                $[ if useCache && useSingleCache ]
                    $[ if entity.hasTag("release:top") && entity.hasAttributeTagged("release:lock") ]
                        $[ let lockAttribute = entity.attributeTagged("release:lock") ]
                    $[/ if ]
                    $[ let indent2 = "" ]
                    $[ if lockAttribute != null ]
                if (modelObject.is${lockAttribute|domain:Model|name|capitalize}()) {
                        $[ let indent2 = indent ]
                    $[/ if ]
                ${indent2}${cacheVariableName}.put(modelObject.getId(), responseObject);
                    $[ if lockAttribute != null ]
                }
                    $[/ if ]
            }
                $[/ if ]
            return responseObject;
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

            $[/ function ]
            $[ let useCache = false ]
            $[ let useSingleCache = false ]
            $[ if entity.hasPrimaryKey ]
                $[ call makeGetByIdServiceMethod(responseDomain: space.domain("Model"), entity: entity, useCache: useCache, useSingleCache: useSingleCache) ]
                $[ call makeGetByIdServiceMethod(responseDomain: space.domain("JSONDTO"), entity: entity, useCache: useCache, useSingleCache: useSingleCache) ]
                $[ if !(entity.module|domain:ProtobufDTO).hasTag("noproto") ]
                    $[ call makeGetByIdServiceMethod(responseDomain: space.domain("ProtobufDTO"), entity: entity, useCache: useCache, useSingleCache: useSingleCache) ]
                $[/ if ]
            $[/ if ]
$[***********]
$[*  COUNT  *]
$[***********]
    public long get${responseModelName}Count() throws ServiceException {
        return ${repositoryVariableName}.count();
    }

$[************]
$[* GET LIST *]
$[************]
    public List<${responseModelName}> get${responseModelName}List(long start, int limit) throws ServiceException {
        try {
            return ${repositoryVariableName}.get${responseModelName}List(start, limit);
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

    public List<${responseDtoName}> get${responseDtoName}List(long start, int limit, boolean hierarchical) throws ServiceException {
        try {
            List<${responseDtoName}> dtoList = new ArrayList<>();
            List<${responseModelName}> list = ${repositoryVariableName}.get${responseModelName}List(start, limit);
            for(${responseModelName} modelObject : list) {
                dtoList.add(dtoFromModel(modelObject, hierarchical));
            }
            return dtoList;
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

$[****************************]
$[* GET LIST BY (attributes) *]
$[****************************]
            $[ function makeGetListByAttributeMethod
               D "This function generates a method to get a list of objects relative to some specified"
               D "attribute." 
               (responseDomain
                D "The domain associated with the response object (e.g, Model, JSONDTO, etc.)." ,
                entity
                D "The entity to which this method is synthesized." ,
                attribute
                D "The attribute to which the results are relative." 
               )
            ]
                $[ let repositoryVariableName = entity|domain:Repository|name|uncapitalize ]
                $[ let responseModelName = entity|domain:Model|name ]
                $[ let responseDtoName = entity|domain:JSONDTO|name ]
                $[ let isDtoVariant = responseDomain.name == "JSONDTO" ]
                $[ let isModelVariant = responseDomain.name == "Model" ]
                $[ let responseClassName = isDtoVariant ? responseDtoName:responseModelName ]
                $[ let responseInMethodName = isDtoVariant ? responseDtoName:responseModelName ]
                $[ capture fullResponseName ]List<${responseClassName}>$[/ capture ]
    public ${fullResponseName} get${responseInMethodName}ListBy${attribute.name|capitalize}(
        ${attribute.type|language} ${attribute.name},
        long start,
        int limit,
        boolean hierarchical) throws ServiceException {

        try {
                $[ let listName = "list" ]
                $[ if isDtoVariant ]
                    $[ let listName = "dtoList" ]
            List<${responseDtoName}> dtoList = new ArrayList<>();
                $[/ if ]
            List<${responseModelName}> list = ${repositoryVariableName}.get${responseModelName}ListBy${attribute.name|capitalize}(${attribute.name}, start, limit);
                $[ if isDtoVariant ]
            for(${responseModelName} modelObject : list) {
                ${listName}.add(dtoFromModel(modelObject, hierarchical));
            }
                $[/ if ]
            return ${listName};
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

            $[/ function ]
            $[ foreach entity.attributes ]
                $[ if !attribute.isParent ]$[ continue ]$[/ if ]
                $[ if attribute.type.isEnumType ]
$[ send imports ]
import ${attribute.type|domain:Model|fullname};
$[/ send ]
                $[/ if ]
                $[ call makeGetListByAttributeMethod(responseDomain: space.domain("Model"), attribute: attribute, entity: entity) ]
                $[ call makeGetListByAttributeMethod(responseDomain: space.domain("JSONDTO"), attribute: attribute, entity: entity) ]
            $[/ foreach ]
$[*******************************]
$[* GET LIST BY (relationships) *]
$[*******************************]
            $[ function makeGetListByRelationshipMethod
               D "This function generates a method to get a list of objects relative to some specified"
               D "relationship." 
               (responseDomain
                D "The domain associated with the response object (e.g, Model, JSONDTO, etc.)." ,
                entity
                D "The entity to which this method is synthesized." ,
                relationship
                D "The relationship to which the results are relative." ,
                getFlavor
                D "The repository get method can have a flavor such as Locked so this can be set to use that flavor." 
               )
            ]
                $[ let protobufClassName = entity|domain:ProtobufDTO|name ]
                $[ capture fullProtobufClassName ]${entity.module|domain:ProtobufDTO|name}.${protobufClassName}$[/ capture ]
                $[ let isDtoVariant = responseDomain.name == "JSONDTO" ]
                $[ let isModelVariant = responseDomain.name == "Model" ]
                $[ let isPBVariant = responseDomain.name == "ProtobufDTO" ]
                $[ let repositoryVariableName = entity|domain:Repository|name|uncapitalize ]
                $[ let responseModelName = entity|domain:Model|name ]
                $[ let responseDtoName = entity|domain:JSONDTO|name ]
                $[ let responseClassName = isDtoVariant ? responseDtoName:isModelVariant ? responseModelName:fullProtobufClassName ]
                $[ let responseInMethodName = isDtoVariant ? responseDtoName:isModelVariant ? responseModelName:protobufClassName + "PB" ]
                $[ let toPrimaryKeyName = relationship.to.entity.primaryKeyAttribute.name ]
                $[ capture fullResponseName ]$[ if isPBVariant ]${responseClassName}List$[ else ]List<${responseClassName}>$[/ if ]$[/ capture ]
    public ${fullResponseName} get${getFlavor}${responseInMethodName}ListBy${relationship.name|capitalize}(
        ${relationship.to.entity.pkType|language} ${toPrimaryKeyName},
        long start,
        int limit,
        boolean hierarchical) throws ServiceException {

        try {
                $[ let listName = "list" ]
                $[ if isDtoVariant ]
                    $[ let listName = "dtoList" ]
            List<${responseDtoName}> dtoList = new ArrayList<>();
                $[ elseif isPBVariant ]
                    $[ let listName = "pbList" ]
            ${fullProtobufClassName}List.Builder pbList = ${fullProtobufClassName}List.newBuilder();
                $[/ if ]
            List<${responseModelName}> list = ${repositoryVariableName}.get${getFlavor}${responseModelName}ListBy${relationship.name|capitalize}(${toPrimaryKeyName}, start, limit);
                $[ if isDtoVariant || isPBVariant ]
            for(${responseModelName} modelObject : list) {
                    $[ if isDtoVariant ]
                ${listName}.add(dtoFromModel(modelObject, hierarchical));
                    $[ else ]
                ${listName}.addItem(protobufFromModel(modelObject));
                    $[/ if ]
            }
                $[/ if ]
                $[ if isPBVariant ]
            return ${listName}.build();
                $[ else ]
            return ${listName};
                $[/ if ]
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

    public Long get${getFlavor}${responseInMethodName}CountBy${relationship.name|capitalize}(
        ${relationship.to.entity.pkType|language} ${toPrimaryKeyName}) throws ServiceException {

        try {
            return ${repositoryVariableName}.count${getFlavor}${responseModelName}By${relationship.name|capitalize}Id(${toPrimaryKeyName});
        } catch (DataAccessException ex) {
            throw new DaoException(ex.getMessage(), ex);
        }
    }

            $[/ function ]
            $[ foreach relationship in entity.relationships if relationship.to.isOne ]
                $[ let getFlavor = null ]
                $[ call makeGetListByRelationshipMethod(responseDomain: space.domain("Model"), relationship: relationship, entity: entity, getFlavor: getFlavor) ]
                $[ call makeGetListByRelationshipMethod(responseDomain: space.domain("JSONDTO"), relationship: relationship, entity: entity, getFlavor: getFlavor) ]
                $[ if !(entity.module|domain:ProtobufDTO).hasTag("noproto") ]
                    $[ call makeGetListByRelationshipMethod(responseDomain: space.domain("ProtobufDTO"), relationship: relationship, entity: entity, getFlavor: getFlavor) ]
                $[/ if ]
$[ outlet parentRelationship ]
$[/ outlet ]
                $[ if getFlavor != null ]
                    $[ call makeGetListByRelationshipMethod(responseDomain: space.domain("Model"), relationship: relationship, entity: entity, getFlavor: getFlavor) ]
                    $[ call makeGetListByRelationshipMethod(responseDomain: space.domain("JSONDTO"), relationship: relationship, entity: entity, getFlavor: getFlavor) ]
                    $[ if !(entity.module|domain:ProtobufDTO).hasTag("noproto") ]
                        $[ call makeGetListByRelationshipMethod(responseDomain: space.domain("ProtobufDTO"), relationship: relationship, entity: entity, getFlavor: getFlavor) ]
                    $[/ if ]
                $[/ if ]
            $[/ foreach ]
            $[ if entity.hasPrimaryParentRelationship ]
                $[ let primaryParentEntity = entity.primaryParentRelationship.to.entity ]
                $[ let pkType = entity.pkType|language ]
                $[ let parentPkType = primaryParentEntity.pkType|language ]
    public ${parentPkType} getParentId(${pkType} objId) {
        Optional<${modelName}> objOptional = ${repositoryVariableName}.getById(objId);
        if (objOptional.isPresent()) {
            ${modelName} obj = objOptional.get();
            ${parentPkType} parentId = obj.get${primaryParentEntity|domain:Model|name}Id();
            return parentId;
        }
        return $[ if primaryParentEntity.pkType.isUUIDType ]null$[ else ]0$[/ if ];
    }

            $[/ if ]
$[ outlet methods
   D "Good place to put get methods."
]
$[/ outlet ]
        $[/ author ]
    $[/ author ]
$[/ publisher ]
    